<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Crumple</title>
    <style>
    body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
    }
    canvas {
        width: 100%;
        height: 100%
    }
    </style>
</head>
<body>
<script src="bower_components/delaunay-fast/delaunay.js"></script>
<script src="bower_components/threejs/build/three.min.js"></script>
<script>
window.onload = function () {
    var sw = window.innerWidth,
        sh = window.innerHeight,
        scene = new THREE.Scene(),
        cameraP = new THREE.PerspectiveCamera(75, sw / sh, 0.1, 1000),
        camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 1, 10),
        renderer = new THREE.WebGLRenderer({ antialias: true });

    renderer.shadowMapEnabled = true;
    renderer.shadowMapType = THREE.PCFSoftShadowMap;

    renderer.setSize(sw, sh);

    document.body.appendChild(renderer.domElement);

    var geometry = new THREE.Geometry(),
        density = 15;

    geometry.vertices.push(
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(1, 0, 0),
        new THREE.Vector3(1, 1, 0),
        new THREE.Vector3(0, 1, 0)
    );

    for (var i = 0; i < density; i++) {
        geometry.vertices.push(
            new THREE.Vector3(Math.random(), 0, 0),
            new THREE.Vector3(0, Math.random(), 0),
            new THREE.Vector3(Math.random(), 1, 0),
            new THREE.Vector3(1, Math.random(), 0)
        );
    }

    for (var i = 0; i < density * density; i++) {
        geometry.vertices.push(
            new THREE.Vector3(Math.random(), Math.random(), 0)
        );
    }

    geometry.vertices.forEach(function (vertex) {
        vertex.x -= 0.5;
        vertex.y -= 0.5;
        vertex.z = 0.1 * Math.random();
    });

    Delaunay.triangulate(geometry.vertices.map(function (vertex) {
        return [ vertex.x, vertex.y ];
    })).forEach(function (vertexIndex, indexIndex, vertexIndices) {
        if (indexIndex % 3 === 2) {
            geometry.faces.push(
                new THREE.Face3(
                    vertexIndices[indexIndex],
                    vertexIndices[indexIndex - 1],
                    vertexIndices[indexIndex - 2]
                )
            );
        }
    });

    geometry.computeFaceNormals();
    // geometry.computeVertexNormals();

    var material = new THREE.MeshLambertMaterial({ color: 0x2d3741, ambient: 0x2d3741 }),
        crumple = new THREE.Mesh(geometry, material);

    crumple.castShadow = true;
    crumple.receiveShadow = true;

    crumple.position.z = -2;
    //scene.add(crumple);

    var geometryC = new THREE.BoxGeometry( 1, 1, 1 );
    var materialC = new THREE.MeshLambertMaterial({ color: 0x2d3741, ambient: 0x2d3741 });
    var cube = new THREE.Mesh( geometryC, materialC );
    cube.position.z = -4;
    cube.position.y = 0.5;
    cube.rotation.x = 0.2;
    cube.rotation.y = 0.4;
    cube.castShadow = true;
    scene.add( cube );

    var geometryG = new THREE.BoxGeometry( 5, 0.1, 5 );
    var materialG = new THREE.MeshLambertMaterial({ color: 0x333333, ambient: 0x333333 });
    var ground = new THREE.Mesh( geometryG, materialG );
    ground.position.z = -4;
    ground.position.y = -0.5;
    ground.rotation.x = 0.2;
    ground.receiveShadow = true;
    //ground.rotation.y = 0.4;
    scene.add( ground );

    var ambient = new THREE.AmbientLight(0x2d3741);
    scene.add(ambient);

    var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);

    directionalLight.position.set(0, 1, 1);
    //directionalLight.target.position.set(0, 0, 0);

    directionalLight.castShadow = true;
    directionalLight.shadowCameraVisible = true;
    // directionalLight.shadowDarkness = 0.5;
    // directionalLight.shadowCameraVisible = true;

    // directionalLight.shadowCameraRight = 0.5;
    // directionalLight.shadowCameraLeft = -0.5;
    // directionalLight.shadowCameraTop = 0.5;
    // directionalLight.shadowCameraBottom = -0.5;
    // directionalLight.shadowCameraNear = 1;
    // directionalLight.shadowCameraFar = 10;

    // renderer.shadowMapEnabled = true;
    // renderer.shadowMapSoft = true;

    // renderer.shadowCameraNear = 1;
    // renderer.shadowCameraFar = 10;
    // renderer.shadowCameraFov = 50;

    // renderer.shadowMapBias = 0.0039;
    // renderer.shadowMapDarkness = 0.5;
    // renderer.shadowMapWidth = 1;
    // renderer.shadowMapHeight = 1;

    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;

    renderer.shadowCameraNear = 1;
    renderer.shadowCameraFar = 100;
    renderer.shadowCameraFov = 50;

    renderer.shadowMapBias = 0.0039;
    renderer.shadowMapDarkness = 0.5;
    renderer.shadowMapWidth = 4;
    renderer.shadowMapHeight = 4;

    //render.shadowCameraVisible = true;

    scene.add(directionalLight);

    scene.add(new THREE.DirectionalLightHelper(directionalLight));

    //var cameraHelper = new THREE.CameraHelper(camera);
    //scene.add(cameraHelper);

    cameraP.position.z = 20.25;
    // cameraP.position.x = 3;

    function render() {
        renderer.render(scene, cameraP);
    }

    render();
};
</script>
</body>
</html>
